#!/bin/bash

RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color
UNMERGED_IGNORE='^(hold|paused)/'
REPO_IGNORE='.disabled$'
DEFAULT_BRANCH=master

function warning(){
    echo -e "${RED}${*}${NC}"
}

function message_ok(){
    echo -e "${GREEN}${*}${NC}"
}

function ref_name(){
    # determine the ref name (http://stackoverflow.com/a/1593487)
    local ref=
    if ref="$(git symbolic-ref HEAD 2>/dev/null)" ; then
        # i am standing on a branch
        # cleaning up:
        ref=${ref##refs/heads/}
    elif ref=$( git describe --tags --abbrev=0 --exact-match 2>/dev/null) ; then
        # iam standing on a tag
        :
    else
        ref=$(git rev-parse --short HEAD)
    fi

    echo $ref

    }

function list_unmerged(){
    git branch --no-merged $DEFAULT_BRANCH | tr -d ' ' | grep -E -v "$UNMERGED_IGNORE"
}

function is_wip(){
    # Rules:
    # default branch
    # uncommited files
    # unmerged branches

    if [ ! -d .git ]; then
        return
    fi

    local messages=()
    local ref
    ref=$(ref_name)


    if [ "$WARN_DEFAULT_BRANCH" == "yes" ]; then
        if [ "$ref" != "master" ] && [ "$ref" != "develop" ] ; then
            messages+=("HEAD is checked out on ref \"$ref\"")
        fi
    fi

    if [ "$WARN_UNTRACKED" == "yes" ]; then
        uncommited_count=$(git status --porcelain | wc -l)
        if [ "$uncommited_count" != "0" ]; then
            messages+=("$uncommited_count uncommited files")
        fi
    fi

    if [ "$WARN_UNMERGED" == "yes" ]; then
        unmerged_branches=$(list_unmerged)
        unmerged_inline=$( echo "$unmerged_branches" | tr '\n' ' ' )
        unmerged_count=$( echo -n "$unmerged_branches" | wc -l )
        if [ "$unmerged_count" != "0" ]; then
            messages+=("$unmerged_count unmerged branches: $unmerged_inline")
        fi
    fi

    messages_count=${#messages[@]}
    if [ "$messages_count" != "0" ]; then
        echo "$repo:"
        for i in "${messages[@]}"; do
            warning "    $i"
        done
    else
        echo -e "${repo}: ${GREEN}OK${NC}"
    fi

}

function is_git_repo() {
    folder=$1
    if [ -n "$REPO_IGNORE" ] && [[ "$(basename $folder)" =~ "$REPO_IGNORE" ]]; then
        return 1
    fi
    pushd $folder > /dev/null
    #>&2 echo "DEBUG: is_git_repo(): current location of is_git_repo: $PWD"
    git rev-parse --is-inside-work-tree 2>/dev/null
    return $?
    R=$?
    popd > /dev/null
    return $R
}

function find_git_repos() {
    search_folder=$@
    for git_folder in $(find $search_folder -type d -name .git); do
        repo=$(dirname $git_folder)
        if $(is_git_repo "$repo"); then
            echo $repo
        else
            >&2 warning "WARNING: $repo is not a git repository"
        fi
    done
}

function print_help(){
    cat << EOF
$0: List the current state of the repos in the selected directory
Usage: $0 [OPTIONS] [PATH]

options:
[PATH]                  the path to scan (default: .)
--no-default-branch,-b  do not warn when current branch is not on default branch
--no-untracked,-u       do not warn when untracked files exist
--no-unmerged,-m        do not warn when unmerged branches exist
--help,-h               print this help
EOF
}

# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash

WARN_DEFAULT_BRANCH=yes
WARN_UNTRACKED=yes
WARN_UNMERGED=yes
while [[ $# -gt 0 ]]; do
  case $1 in
    -b|--no-default-branch)
      WARN_DEFAULT_BRANCH=no
      shift
      ;;
    -u|--no-untracked)
      WARN_UNTRACKED=no
      shift
      ;;
    -m|--no-unmerged)
      WARN_UNMERGED=no
      shift
      ;;
    -h|--help)
      print_help
      exit 0
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      FOLDER=$1
      shift # past argument
      ;;
  esac
done


for repo in $(find_git_repos $FOLDER); do
    pushd "$repo" > /dev/null
    is_wip
    popd > /dev/null
done

exit 0
